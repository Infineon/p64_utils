<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PSoC64 Secure Boot Utilities Middleware Library 1.0: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="IFXCYP_one-line.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PSoC64 Secure Boot Utilities Middleware Library 1.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__syscalls__api.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__syscalls.html">Syscalls</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0797f0d30bfbdbb9e18f17154f008864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls__api.html#ga0797f0d30bfbdbb9e18f17154f008864">cy_p64_get_provisioning_details</a> (uint32_t id, char **ptr, uint32_t *len)</td></tr>
<tr class="memdesc:ga0797f0d30bfbdbb9e18f17154f008864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the provisioning packet (JWT), policy templates or public keys strings in the JSON format.  <a href="#ga0797f0d30bfbdbb9e18f17154f008864">More...</a><br /></td></tr>
<tr class="separator:ga0797f0d30bfbdbb9e18f17154f008864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae48c6aa700baf53f8ac5dc1b02a50e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls__api.html#gaae48c6aa700baf53f8ac5dc1b02a50e7">cy_p64_access_port_control</a> (<a class="el" href="group__syscalls__t.html#ga90b6f0685b96a114749254059c996f06">cy_p64_ap_name_t</a> ap, <a class="el" href="group__syscalls__t.html#gacb86ddedc0e6f0e8b207393ef64d866b">cy_p64_ap_control_t</a> control)</td></tr>
<tr class="memdesc:gaae48c6aa700baf53f8ac5dc1b02a50e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to control DAP access during run-time.  <a href="#gaae48c6aa700baf53f8ac5dc1b02a50e7">More...</a><br /></td></tr>
<tr class="separator:gaae48c6aa700baf53f8ac5dc1b02a50e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2643b7135088d42e04320701e6113d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls__api.html#gac2643b7135088d42e04320701e6113d8">cy_p64_acquire_response</a> (void)</td></tr>
<tr class="memdesc:gac2643b7135088d42e04320701e6113d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this function only when TEST_MODE bit is set in the SRSS_TST_MODE register, use <a class="el" href="group__syscalls__macros.html#ga4267537ed88041f8b478be38fdef38b5" title="Verifies if TEST_MODE bit is set in the SRSS_TST_MODE register. ">CY_P64_IS_TEST_MODE_SET()</a> macro to check.  <a href="#gac2643b7135088d42e04320701e6113d8">More...</a><br /></td></tr>
<tr class="separator:gac2643b7135088d42e04320701e6113d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd7f689b75190429a9b0469a9b2ddfcd"><td class="memItemLeft" align="right" valign="top">CY_RAMFUNC_BEGIN CY_NOINLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls__api.html#gabd7f689b75190429a9b0469a9b2ddfcd">cy_p64_acquire_test_bit_loop</a> (void)</td></tr>
<tr class="memdesc:gabd7f689b75190429a9b0469a9b2ddfcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called after <a class="el" href="group__syscalls__api.html#gac2643b7135088d42e04320701e6113d8" title="Call this function only when TEST_MODE bit is set in the SRSS_TST_MODE register, use CY_P64_IS_TEST_M...">cy_p64_acquire_response()</a>.  <a href="#gabd7f689b75190429a9b0469a9b2ddfcd">More...</a><br /></td></tr>
<tr class="separator:gabd7f689b75190429a9b0469a9b2ddfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb420863da291417351804dcda9cee4"><td class="memItemLeft" align="right" valign="top">CY_RAMFUNC_END <a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls__api.html#ga8fb420863da291417351804dcda9cee4">cy_p64_get_rollback_counter</a> (uint32_t number, uint32_t *value)</td></tr>
<tr class="memdesc:ga8fb420863da291417351804dcda9cee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads the rollback counter.  <a href="#ga8fb420863da291417351804dcda9cee4">More...</a><br /></td></tr>
<tr class="separator:ga8fb420863da291417351804dcda9cee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591222f0fe10e023697e31126e4bd94f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls__api.html#ga591222f0fe10e023697e31126e4bd94f">cy_p64_update_rollback_counter</a> (uint32_t number, uint32_t value)</td></tr>
<tr class="memdesc:ga591222f0fe10e023697e31126e4bd94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the rollback counter to a higher value only.  <a href="#ga591222f0fe10e023697e31126e4bd94f">More...</a><br /></td></tr>
<tr class="separator:ga591222f0fe10e023697e31126e4bd94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7c68224f16b83b2230f22cf4ca308e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__syscalls__api.html#ga6c7c68224f16b83b2230f22cf4ca308e">cy_p64_attestation</a> (uint32_t sign_alg, uint32_t rnd, uint32_t mem_count, const uint32_t *mem_start_addr, const uint32_t *mem_sizes, const uint32_t *hash_addr, uint32_t hash_size, uint32_t *rnd_out, uint32_t *mem_hash_size, uint32_t *sign_size, uint32_t *sign_addr)</td></tr>
<tr class="memdesc:ga6c7c68224f16b83b2230f22cf4ca308e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates hashes of memory regions provided in an input array.  <a href="#ga6c7c68224f16b83b2230f22cf4ca308e">More...</a><br /></td></tr>
<tr class="separator:ga6c7c68224f16b83b2230f22cf4ca308e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0797f0d30bfbdbb9e18f17154f008864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0797f0d30bfbdbb9e18f17154f008864">&#9670;&nbsp;</a></span>cy_p64_get_provisioning_details()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a> cy_p64_get_provisioning_details </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the provisioning packet (JWT), policy templates or public keys strings in the JSON format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Item id (provisioning packet, templates or public keys):<ul>
<li>0 to 32 - Key slot in SFB Mbed Crypto Key Storage</li>
<li>0x100 - FB_POLICY_JWT</li>
<li>0x101 - FB_POLICY_TEMPL_BOOT</li>
<li>0x102 - FB_POLICY_TEMPL_DEBUG</li>
<li>0x2xx - FB_POLICY_CERTIFICATE, where xx is a certificate index in the "chain_of_trust" array of the provisioned packet.</li>
<li>0x300 - FB_POLICY_IMG_CERTIFICATE </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ptr</td><td>The pointer to the response string. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">len</td><td>The length of the response string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__syscall__macros.html#ga3f4d7112a86369c6933e46f3dbad09e0">CY_P64_SUCCESS</a> for success or error code </dd></dl>

</div>
</div>
<a id="gaae48c6aa700baf53f8ac5dc1b02a50e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae48c6aa700baf53f8ac5dc1b02a50e7">&#9670;&nbsp;</a></span>cy_p64_access_port_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a> cy_p64_access_port_control </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__syscalls__t.html#ga90b6f0685b96a114749254059c996f06">cy_p64_ap_name_t</a>&#160;</td>
          <td class="paramname"><em>ap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__syscalls__t.html#gacb86ddedc0e6f0e8b207393ef64d866b">cy_p64_ap_control_t</a>&#160;</td>
          <td class="paramname"><em>control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to control DAP access during run-time. </p>
<p>It works only when particular Debug Access Port has permission set to "allowed" and control field is set to "open" in Debug policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>Access port name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">control</td><td>Control value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__syscall__macros.html#ga3f4d7112a86369c6933e46f3dbad09e0">CY_P64_SUCCESS</a> for success or error code </dd></dl>

</div>
</div>
<a id="gac2643b7135088d42e04320701e6113d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2643b7135088d42e04320701e6113d8">&#9670;&nbsp;</a></span>cy_p64_acquire_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a> cy_p64_acquire_response </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this function only when TEST_MODE bit is set in the SRSS_TST_MODE register, use <a class="el" href="group__syscalls__macros.html#ga4267537ed88041f8b478be38fdef38b5" title="Verifies if TEST_MODE bit is set in the SRSS_TST_MODE register. ">CY_P64_IS_TEST_MODE_SET()</a> macro to check. </p>
<p>It sends acquire response, i.e. sets a magic number in the protected RAM by calling a syscall. The code after this function should wait until TEST_MODE is cleared by the debugger, call <a class="el" href="group__syscalls__api.html#gabd7f689b75190429a9b0469a9b2ddfcd" title="This function should be called after cy_p64_acquire_response(). ">cy_p64_acquire_test_bit_loop()</a>. Acquire procedure is described in PSoC 64 Programming Specification 002-31353 rev** section 5.3.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__syscall__macros.html#ga3f4d7112a86369c6933e46f3dbad09e0">CY_P64_SUCCESS</a> for success or error code </dd></dl>

</div>
</div>
<a id="gabd7f689b75190429a9b0469a9b2ddfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd7f689b75190429a9b0469a9b2ddfcd">&#9670;&nbsp;</a></span>cy_p64_acquire_test_bit_loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CY_RAMFUNC_BEGIN CY_NOINLINE void cy_p64_acquire_test_bit_loop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called after <a class="el" href="group__syscalls__api.html#gac2643b7135088d42e04320701e6113d8" title="Call this function only when TEST_MODE bit is set in the SRSS_TST_MODE register, use CY_P64_IS_TEST_M...">cy_p64_acquire_response()</a>. </p>
<p>It is executed from SRAM and waits until TEST_MODE bit is cleared in the SRSS_TST_MODE register by the debugger. The acquire procedure is described in PSoC 64 Programming Specification 002-31353 rev** section 5.3. </p>

</div>
</div>
<a id="ga8fb420863da291417351804dcda9cee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fb420863da291417351804dcda9cee4">&#9670;&nbsp;</a></span>cy_p64_get_rollback_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CY_RAMFUNC_END <a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a> cy_p64_get_rollback_counter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads the rollback counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>Rollback counter number (0-15). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">*value</td><td>The pointer to the read value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__syscall__macros.html#ga3f4d7112a86369c6933e46f3dbad09e0">CY_P64_SUCCESS</a> for success or error code </dd></dl>

</div>
</div>
<a id="ga591222f0fe10e023697e31126e4bd94f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga591222f0fe10e023697e31126e4bd94f">&#9670;&nbsp;</a></span>cy_p64_update_rollback_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a> cy_p64_update_rollback_counter </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the rollback counter to a higher value only. </p>
<p>This syscall is used by Bootloader to prevent firmware reversion during firmware update.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">number</td><td>Rollback counter number (0-15). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A new value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__syscall__macros.html#ga3f4d7112a86369c6933e46f3dbad09e0">CY_P64_SUCCESS</a> for success or error code </dd></dl>

</div>
</div>
<a id="ga6c7c68224f16b83b2230f22cf4ca308e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c7c68224f16b83b2230f22cf4ca308e">&#9670;&nbsp;</a></span>cy_p64_attestation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__syscall__t.html#ga19cdcf1c811882dca25f294532ec8ae2">cy_p64_error_codes_t</a> cy_p64_attestation </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sign_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mem_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>mem_start_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>mem_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>hash_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>hash_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>rnd_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>mem_hash_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>sign_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>sign_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates hashes of memory regions provided in an input array. </p>
<p>Calculates the signature of a certificate that attests the device state at the moment of signing. Signature is calculated for the following data structure:</p><ul>
<li>Server random number (uint32_t)</li>
<li>Syscall random number (uint32_t)</li>
<li>Device UID (SFLASH-&gt;DIE_LOT array, 11 bytes)</li>
<li>Device Identity (cy_flashDeviceKeyData array, 512 bytes)</li>
<li>OEM Public key and Product ID (cy_flashProvKeyData array, 512 bytes)</li>
<li>Chain of trust (cy_flashChainOfTrust array, 5 kbytes)</li>
<li>Image certificate (cy_flashImgCertJWT array, 1 kbytes)</li>
<li>Policy package (cy_flashProvisionJWT array, 10 kbytes)</li>
<li>Number of memory regions (uint32_t)</li>
<li>for (each memory region):<ul>
<li>Memory region address (uint32_t)</li>
<li>Memory region size (uint32_t)</li>
<li>Memory region content (uint8_t array)</li>
<li>Memory region hash (calculated with the syscall random number at the beginning) (uint8_t array)</li>
</ul>
</li>
</ul>
<p>The signature is calculated without any additional padding / aligning between different certificate fields. Memory regions can be from SRAM, Flash, WFlash, SFlash. SMIF and peripheral address space is not supported. AttestationSysCall algorithm: Generate syscall random number. Init signature hash calculation. Update signature hash with Server/Syscall random numbers, DevUID, Dev public key, policy package. Update signature hash with Number of regions. Check whether the array with memory regions has at least read access allowed for the caller (to avoid side channel attacks) for (each specified memory region) { Start region hash calculation with the syscall random number. Update signature and region hash with a region content (in parallel using the same data). Update signature hash with the region hash. Verify writing rights of the caller and sufficient memory size. Output the region hash to corresponding memory. } Signs the signature hash with a device private key. Clears Crypto Block internal memories and used stack.</p>
<p>An example of real life usage: There is a server which knows information about all connected devices in the field, their IDs, Public keys, available versions of FW. The server wants to know exact state of one of the devices - whether it is hacked or not, which FW versions it has, which configuration. The server sends a request to the device and asks to send back a signed certificate with hashes and content of specific memory regions. The application (through SPM service) calls the SysCall which calculates hashes of the specified regions and create a signature of a data certificate with specific structure. SPM code creates a package with all needed data, includes their calculated hashes and signature, and returns it to Application. Application sends it back to server.</p>
<p>This syscall is not available for PSoC64_512K device</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sign_alg</td><td>PSA signing algorithm (contains hash algorithm type used both for signature and memory region hashes). Only PSA_ALG_ECDSA(PSA_ALG_SHA_256) is allowed at the moment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rnd</td><td>A random number from server </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_count</td><td>The number of memory regions in the array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_start_addr</td><td>The pointer to array of memory region start addresses </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_sizes</td><td>The pointer to array of memory region sizes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_addr</td><td>The pointer to array for hashes of the memory regions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hash_size</td><td>The size in bytes of the array for hashes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rnd_out</td><td>A random number from syscall. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mem_hash_size</td><td>The size in bytes of each memory region Hash. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sign_size</td><td>The size in bytes of the signature. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sign_addr</td><td>The address where the signature is stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__syscall__macros.html#ga3f4d7112a86369c6933e46f3dbad09e0">CY_P64_SUCCESS</a> for success or error code </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>PSoC64 Secure Boot Utilities Middleware Library 1.0</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
